import 'dart:async';

import 'package:analyzer/dart/element/element.dart';
import 'package:analyzer/dart/element/type.dart';
import 'package:build/build.dart';
import 'package:dart_style/dart_style.dart';
import 'package:logging/logging.dart';
import 'package:mcp_server_dart/src/annotations.dart';
import 'package:source_gen/source_gen.dart';

/// Builder function for build.yaml
Builder mcpBuilder(BuilderOptions options) =>
    LibraryBuilder(MCPGenerator(), generatedExtension: '.g.dart');

/// Simple generator that processes all methods in MCP classes
class MCPGenerator extends Generator {
  static final _logger = Logger('MCPGenerator');

  // Type checkers for MCP annotations
  static const _mcpToolChecker = TypeChecker.typeNamed(MCPTool);
  static const _mcpResourceChecker = TypeChecker.typeNamed(MCPResource);
  static const _mcpPromptChecker = TypeChecker.typeNamed(MCPPrompt);

  @override
  FutureOr<String?> generate(LibraryReader library, BuildStep buildStep) {
    final sourceFile = buildStep.inputId.path.split('/').last;
    final buffer = StringBuffer();

    // Check if this library has any MCP annotations at all
    bool hasAnyMCPAnnotations = false;

    // Process all classes in the library
    for (final element in library.allElements) {
      if (element is ClassElement) {
        final className = element.name;

        if (className != null) {
          // Find methods that have MCP annotations
          final annotatedMethods = element.methods
              .where(
                (m) =>
                    m.name != null &&
                    !m.isPrivate &&
                    !m.name!.startsWith('_') &&
                    m.name != 'registerGeneratedHandlers' &&
                    _hasAnyMCPAnnotation(m),
              )
              .toList();

          // Only generate code if there are annotated methods
          if (annotatedMethods.isNotEmpty) {
            hasAnyMCPAnnotations = true;
            buffer.writeln(
              _generateExtension(className, annotatedMethods, sourceFile),
            );
          }
        }
      }
    }

    // Only return generated code if we actually found MCP annotations
    if (!hasAnyMCPAnnotations) return null;

    // Format the generated code with dart_style
    final formatter = DartFormatter(
      languageVersion: DartFormatter.latestLanguageVersion,
    );
    try {
      return formatter.format(buffer.toString());
    } catch (e) {
      // If formatting fails, return unformatted code
      _logger.warning('Failed to format generated code: $e');
      return buffer.toString();
    }
  }

  String _generateExtension(
    String className,
    List<MethodElement> methods,
    String sourceFile,
  ) {
    final buffer = StringBuffer();

    // File header with documentation
    buffer.writeln('''// ignore_for_file: type=lint
part of '$sourceFile';

/// Generated extension for [$className] that automatically registers
/// all annotated MCP tools, resources, and prompts with the server.
///
/// This code is automatically generated by the MCP Dart framework.
/// Do not modify this file directly - instead, modify the source
/// class and run `dart run build_runner build` to regenerate.
extension ${className}Generated on $className {
  /// Registers all MCP handlers that were annotated in the source class.
  ///
  /// This method should be called once during server initialization
  /// to register all tools, resources, and prompts with the MCP server.
  ///
   /// Example:
   /// ```dart
   /// final server = $className();
   /// server.registerGeneratedHandlers(); // Register all annotated methods
   /// await server.start(); // Start the server
   /// ```
  void registerGeneratedHandlers() {''');

    for (int i = 0; i < methods.length; i++) {
      final method = methods[i];
      final methodName = method.name!;
      final methodDoc = method.documentationComment;
      final isFirstMethod = i == 0;

      // Add spacing before each method (except the first one)
      if (!isFirstMethod) {
        buffer.writeln('');
      }

      // Determine annotation type and generate appropriate registration
      final annotationType = _getAnnotationType(method);
      final registrationMethod = _getRegistrationMethod(annotationType);

      // Add comment for the method
      buffer.writeln(
        '    // Register handler for @$annotationType(\'$methodName\')',
      );
      if (methodDoc != null) {
        final cleanDoc = methodDoc
            .replaceAll('///', '')
            .replaceAll('//', '')
            .trim();
        if (cleanDoc.isNotEmpty) {
          buffer.writeln('    // $cleanDoc');
        }
      }

      buffer.writeln('    $registrationMethod(');
      buffer.writeln('      \'$methodName\',');
      if (annotationType == 'MCPTool') {
        buffer.writeln('      (context) async {');
      } else if (annotationType == 'MCPResource') {
        buffer.writeln('      (uri) async {');
      } else if (annotationType == 'MCPPrompt') {
        buffer.writeln('      (args) {');
      }

      // Generate parameter extraction based on annotation type
      if (annotationType == 'MCPTool') {
        // For tools, extract from context
        final hasParams = method.formalParameters.isNotEmpty;
        if (hasParams) {
          buffer.writeln('        // Extract parameters from MCP context');
        }

        for (final param in method.formalParameters) {
          final paramName = param.name;
          if (paramName == null) continue;

          final isOptional = param.isOptional;
          final paramType = _getTypeString(param.type);

          if (isOptional) {
            final defaultValue = param.defaultValueCode ?? 'null';
            final paramExtraction = _generateOptionalParameterExtraction(
              paramName,
              paramType,
              defaultValue,
            );
            buffer.writeln('        $paramExtraction');
          } else {
            final paramExtraction = _generateRequiredParameterExtraction(
              paramName,
              paramType,
            );
            buffer.writeln('        $paramExtraction');
          }
        }
      } else if (annotationType == 'MCPResource') {
        // For resources, the first parameter should be uri, others extracted from context if needed
        // But typically resources just take a uri parameter
        buffer.writeln('        // uri parameter passed directly from handler');
      } else if (annotationType == 'MCPPrompt') {
        // For prompts, check if method already takes Map<String, dynamic> args
        final hasMapParameter =
            method.formalParameters.length == 1 &&
            method.formalParameters.first.type.toString().contains(
              'Map<String, dynamic>',
            );

        if (hasMapParameter) {
          buffer.writeln('        // args parameter passed directly to method');
        } else {
          // Extract individual parameters from args Map
          final hasParams = method.formalParameters.isNotEmpty;
          if (hasParams) {
            buffer.writeln('        // Extract parameters from args Map');
          }

          for (final param in method.formalParameters) {
            final paramName = param.name;
            if (paramName == null) continue;

            final isOptional = param.isOptional;
            final paramType = _getTypeString(param.type);

            if (isOptional) {
              final defaultValue = param.defaultValueCode ?? 'null';
              buffer.writeln(
                '        final $paramName = args[\'$paramName\'] as $paramType? ?? $defaultValue;',
              );
            } else {
              buffer.writeln(
                '        final $paramName = args[\'$paramName\'] as $paramType;',
              );
            }
          }
        }
      }

      // Generate method call based on annotation type
      buffer.writeln('');
      buffer.writeln(
        '        // Call the original method with extracted parameters',
      );

      if (annotationType == 'MCPTool') {
        // For tools, use extracted parameters
        final positionalArgs = method.formalParameters
            .where((p) => p.isRequiredPositional && p.name != null)
            .map((p) => p.name!)
            .join(', ');
        final namedArgs = method.formalParameters
            .where((p) => p.isNamed && p.name != null)
            .map((p) => '${p.name}: ${p.name}')
            .join(', ');

        final args = [
          if (positionalArgs.isNotEmpty) positionalArgs,
          if (namedArgs.isNotEmpty) namedArgs,
        ].join(', ');

        if (method.returnType.toString().contains('Future')) {
          buffer.writeln('        return await $methodName($args);');
        } else {
          buffer.writeln('        return $methodName($args);');
        }
      } else if (annotationType == 'MCPResource') {
        // For resources, pass uri directly (assuming first parameter is uri)
        if (method.returnType.toString().contains('Future')) {
          buffer.writeln('        return await $methodName(uri);');
        } else {
          buffer.writeln('        return $methodName(uri);');
        }
      } else if (annotationType == 'MCPPrompt') {
        // For prompts, check if method takes Map<String, dynamic> directly
        final hasMapParameter =
            method.formalParameters.length == 1 &&
            method.formalParameters.first.type.toString().contains(
              'Map<String, dynamic>',
            );

        if (hasMapParameter) {
          // Pass args directly to method
          buffer.writeln('        return $methodName(args);');
        } else {
          // Use extracted parameters
          final positionalArgs = method.formalParameters
              .where((p) => p.isRequiredPositional && p.name != null)
              .map((p) => p.name!)
              .join(', ');
          final namedArgs = method.formalParameters
              .where((p) => p.isNamed && p.name != null)
              .map((p) => '${p.name}: ${p.name}')
              .join(', ');

          final args = [
            if (positionalArgs.isNotEmpty) positionalArgs,
            if (namedArgs.isNotEmpty) namedArgs,
          ].join(', ');

          buffer.writeln('        return $methodName($args);');
        }
      }

      buffer.writeln('      },');
      if (annotationType == 'MCPTool') {
        buffer.writeln(
          '      description: \'Generated handler for $methodName\',',
        );
      }
      buffer.writeln('    );');
    }

    buffer.writeln('  }');
    buffer.writeln('');

    // Collect available tools, resources, and prompts from the methods
    final availableTools = methods
        .where((m) => _getAnnotationType(m) == 'MCPTool')
        .map((m) => m.name!)
        .toList();
    final availableResources = methods
        .where((m) => _getAnnotationType(m) == 'MCPResource')
        .map((m) => m.name!)
        .toList();
    final availablePrompts = methods
        .where((m) => _getAnnotationType(m) == 'MCPPrompt')
        .map((m) => m.name!)
        .toList();

    buffer.writeln(
      '  /// Generates standardized usage documentation for MCP servers.',
    );
    buffer.writeln('  ///');
    buffer.writeln(
      '  /// This helper method provides consistent help text formatting',
    );
    buffer.writeln(
      '  /// for this specific MCP server with its available capabilities.',
    );
    buffer.writeln(' void showUsage({String? serverName}) {');
    buffer.writeln(
      '''    print('Usage: dart \${serverName ?? "server"}.dart [options]');
    print('');
    print('Options:');
    print('  --stdio        Start server in stdio mode (default)');
    print('  --http         Start HTTP server on port 8080');
    print('  --port <port>  Specify HTTP port (default: 8080)');
    print('  --help, -h     Show this help message');
    print('');''',
    );

    if (availableTools.isNotEmpty) {
      buffer.writeln(
        '    print(\'Available tools: ${availableTools.join(", ")}\');',
      );
    }
    if (availableResources.isNotEmpty) {
      buffer.writeln(
        '    print(\'Available resources: ${availableResources.join(", ")}\');',
      );
    }
    if (availablePrompts.isNotEmpty) {
      buffer.writeln(
        '    print(\'Available prompts: ${availablePrompts.join(", ")}\');',
      );
    }

    if (availableTools.isNotEmpty ||
        availableResources.isNotEmpty ||
        availablePrompts.isNotEmpty) {
      buffer.writeln('    print(\'\');');
    }

    buffer.writeln('''    print('Examples:');
    print('  dart \${serverName ?? "server"}.dart');
    print('  dart \${serverName ?? "server"}.dart --http');
    print('  dart \${serverName ?? "server"}.dart --http --port 3000');''');
    buffer.writeln('  }');
    buffer.writeln('');
    buffer.writeln('}');

    return buffer.toString();
  }

  /// Generate parameter extraction for required parameters using generic type inference
  String _generateRequiredParameterExtraction(
    String paramName,
    String paramType,
  ) {
    // Use generic type inference - let the context.param<T> method handle the conversion
    return 'final $paramName = context.param<$paramType>(\'$paramName\');';
  }

  /// Generate parameter extraction for optional parameters using generic type inference
  String _generateOptionalParameterExtraction(
    String paramName,
    String paramType,
    String defaultValue,
  ) {
    // Use generic type inference - let the context.optionalParam<T> method handle the conversion
    return 'final $paramName = context.optionalParam<$paramType>(\'$paramName\') ?? $defaultValue;';
  }

  /// Get string representation of Dart type for generic type parameters
  String _getTypeString(DartType type) {
    if (type.isDartAsyncFuture) {
      final futureType = type as InterfaceType;
      if (futureType.typeArguments.isNotEmpty) {
        return _getTypeString(futureType.typeArguments.first);
      }
    }

    // Handle common types
    if (type.isDartCoreString) return 'String';
    if (type.isDartCoreInt) return 'int';
    if (type.isDartCoreDouble) return 'double';
    if (type.isDartCoreBool) return 'bool';
    if (type.isDartCoreList) return 'List<dynamic>';
    if (type.isDartCoreMap) return 'Map<String, dynamic>';

    return type.getDisplayString();
  }

  /// Check if a method has any MCP annotation
  bool _hasAnyMCPAnnotation(MethodElement method) {
    // Use the type checkers to properly detect MCP annotations
    return _mcpToolChecker.hasAnnotationOfExact(method) ||
        _mcpResourceChecker.hasAnnotationOfExact(method) ||
        _mcpPromptChecker.hasAnnotationOfExact(method);
  }

  /// Get the annotation type for a method
  String _getAnnotationType(MethodElement method) {
    if (_mcpToolChecker.hasAnnotationOfExact(method)) {
      return 'MCPTool';
    } else if (_mcpResourceChecker.hasAnnotationOfExact(method)) {
      return 'MCPResource';
    } else if (_mcpPromptChecker.hasAnnotationOfExact(method)) {
      return 'MCPPrompt';
    }
    return 'MCPTool'; // Default fallback
  }

  /// Get the registration method name for an annotation type
  String _getRegistrationMethod(String annotationType) {
    switch (annotationType) {
      case 'MCPTool':
        return 'registerTool';
      case 'MCPResource':
        return 'registerResource';
      case 'MCPPrompt':
        return 'registerPrompt';
      default:
        return 'registerTool';
    }
  }
}
