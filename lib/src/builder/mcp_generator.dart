import 'dart:async';

import 'package:analyzer/dart/element/element.dart';
import 'package:analyzer/dart/element/type.dart';
import 'package:build/build.dart';
import 'package:dart_style/dart_style.dart';
import 'package:logging/logging.dart';
import 'package:mcp_server_dart/src/annotations.dart';
import 'package:source_gen/source_gen.dart';

/// Builder function for build.yaml
Builder mcpBuilder(BuilderOptions options) =>
    LibraryBuilder(MCPGenerator(), generatedExtension: '.mcp.dart');

/// Simple generator that processes all methods in MCP classes
class MCPGenerator extends Generator {
  static final _logger = Logger('MCPGenerator');

  // Type checkers for MCP annotations
  static const _mcpToolChecker = TypeChecker.typeNamed(MCPTool);
  static const _mcpResourceChecker = TypeChecker.typeNamed(MCPResource);
  static const _mcpPromptChecker = TypeChecker.typeNamed(MCPPrompt);

  @override
  FutureOr<String?> generate(LibraryReader library, BuildStep buildStep) {
    final sourceFile = buildStep.inputId.path.split('/').last;
    final buffer = StringBuffer();

    // Check if this library has any MCP annotations at all
    bool hasAnyMCPAnnotations = false;

    // Process all classes in the library
    for (final element in library.allElements) {
      if (element is ClassElement) {
        final className = element.name;

        if (className != null) {
          // Find methods that have MCP annotations
          final annotatedMethods = element.methods
              .where(
                (m) =>
                    m.name != null &&
                    !m.isPrivate &&
                    !m.name!.startsWith('_') &&
                    m.name != 'registerGeneratedHandlers' &&
                    _hasAnyMCPAnnotation(m),
              )
              .toList();

          // Only generate code if there are annotated methods
          if (annotatedMethods.isNotEmpty) {
            hasAnyMCPAnnotations = true;
            buffer.writeln(
              _generateExtension(className, annotatedMethods, sourceFile),
            );
          }
        }
      }
    }

    // Only return generated code if we actually found MCP annotations
    if (!hasAnyMCPAnnotations) return null;

    // Format the generated code with dart_style
    final formatter = DartFormatter(
      languageVersion: DartFormatter.latestLanguageVersion,
    );
    try {
      return formatter.format(buffer.toString());
    } catch (e) {
      // If formatting fails, return unformatted code
      _logger.warning('Failed to format generated code: $e');
      return buffer.toString();
    }
  }

  String _generateExtension(
    String className,
    List<MethodElement> methods,
    String sourceFile,
  ) {
    final buffer = StringBuffer();

    // File header with documentation
    buffer.writeln('''// ignore_for_file: type=lint
part of '$sourceFile';

/// Generated extension for [$className] that automatically registers
/// all annotated MCP tools, resources, and prompts with the server.
///
/// This code is automatically generated by the MCP Dart framework.
/// Do not modify this file directly - instead, modify the source
/// class and run `dart run build_runner build` to regenerate.
extension ${className}Generated on $className {
  /// Registers all MCP handlers that were annotated in the source class.
  /// This method is automatically called during server initialization.
  void registerGeneratedHandlers() {''');

    for (int i = 0; i < methods.length; i++) {
      final method = methods[i];
      final methodName = method.name!;
      final methodDoc = method.documentationComment;
      final isFirstMethod = i == 0;

      // Add spacing before each method (except the first one)
      if (!isFirstMethod) {
        buffer.writeln('');
      }

      // Determine annotation type and get annotation details
      final annotationType = _getAnnotationType(method);
      final annotationName = _getAnnotationName(method);
      final annotationDescription = _getAnnotationDescription(method);
      final registrationMethod = _getRegistrationMethod(annotationType);

      // Add comment for the method
      buffer.writeln(
        '    // Register handler for @$annotationType(\'$annotationName\')',
      );
      if (methodDoc != null) {
        final cleanDoc = methodDoc
            .replaceAll('///', '')
            .replaceAll('//', '')
            .trim();
        if (cleanDoc.isNotEmpty) {
          buffer.writeln('    // $cleanDoc');
        }
      }

      buffer.writeln('    $registrationMethod(');
      buffer.writeln('      \'$annotationName\',');
      if (annotationType == 'MCPTool') {
        buffer.writeln('      (context) async {');
      } else if (annotationType == 'MCPResource') {
        buffer.writeln('      (uri) async {');
      } else if (annotationType == 'MCPPrompt') {
        buffer.writeln('      (args) {');
      }

      // Generate parameter extraction based on annotation type
      if (annotationType == 'MCPTool') {
        for (final param in method.formalParameters) {
          final paramName = param.name;
          if (paramName == null) continue;

          final isOptional = param.isOptional;
          final paramType = _getTypeString(param.type);

          if (isOptional) {
            final defaultValue = param.defaultValueCode ?? 'null';
            final paramExtraction = _generateOptionalParameterExtraction(
              paramName,
              paramType,
              defaultValue,
            );
            buffer.writeln('        $paramExtraction');
          } else {
            final paramExtraction = _generateRequiredParameterExtraction(
              paramName,
              paramType,
            );
            buffer.writeln('        $paramExtraction');
          }
        }
      } else if (annotationType == 'MCPPrompt') {
        // For prompts, check if method already takes Map<String, dynamic> args
        final hasMapParameter =
            method.formalParameters.length == 1 &&
            method.formalParameters.first.type.toString().contains(
              'Map<String, dynamic>',
            );

        if (!hasMapParameter) {
          // Extract individual parameters from args Map
          for (final param in method.formalParameters) {
            final paramName = param.name;
            if (paramName == null) continue;

            final isOptional = param.isOptional;
            final paramType = _getTypeString(param.type);

            if (isOptional) {
              final defaultValue = param.defaultValueCode ?? 'null';
              buffer.writeln(
                '        final $paramName = args[\'$paramName\'] as $paramType? ?? $defaultValue;',
              );
            } else {
              buffer.writeln(
                '        final $paramName = args[\'$paramName\'] as $paramType;',
              );
            }
          }
        }
      }

      // Generate method call based on annotation type
      if (annotationType == 'MCPTool') {
        // For tools, use extracted parameters
        final positionalArgs = method.formalParameters
            .where((p) => p.isRequiredPositional && p.name != null)
            .map((p) => p.name!)
            .join(', ');
        final namedArgs = method.formalParameters
            .where((p) => p.isNamed && p.name != null)
            .map((p) => '${p.name}: ${p.name}')
            .join(', ');

        final args = [
          if (positionalArgs.isNotEmpty) positionalArgs,
          if (namedArgs.isNotEmpty) namedArgs,
        ].join(', ');

        if (method.returnType.toString().contains('Future')) {
          buffer.writeln('        return await $methodName($args);');
        } else {
          buffer.writeln('        return $methodName($args);');
        }
      } else if (annotationType == 'MCPResource') {
        // For resources, pass uri directly (assuming first parameter is uri)
        if (method.returnType.toString().contains('Future')) {
          buffer.writeln('        return await $methodName(uri);');
        } else {
          buffer.writeln('        return $methodName(uri);');
        }
      } else if (annotationType == 'MCPPrompt') {
        // For prompts, check if method takes Map<String, dynamic> directly
        final hasMapParameter =
            method.formalParameters.length == 1 &&
            method.formalParameters.first.type.toString().contains(
              'Map<String, dynamic>',
            );

        if (hasMapParameter) {
          // Pass args directly to method
          buffer.writeln('        return $methodName(args);');
        } else {
          // Use extracted parameters
          final positionalArgs = method.formalParameters
              .where((p) => p.isRequiredPositional && p.name != null)
              .map((p) => p.name!)
              .join(', ');
          final namedArgs = method.formalParameters
              .where((p) => p.isNamed && p.name != null)
              .map((p) => '${p.name}: ${p.name}')
              .join(', ');

          final args = [
            if (positionalArgs.isNotEmpty) positionalArgs,
            if (namedArgs.isNotEmpty) namedArgs,
          ].join(', ');

          buffer.writeln('        return $methodName($args);');
        }
      }

      buffer.writeln('      },');

      // Add description and input schema for tools
      if (annotationType == 'MCPTool') {
        final description = annotationDescription.isNotEmpty
            ? annotationDescription
            : 'Generated handler for $methodName';
        buffer.writeln('      description: \'$description\',');

        // Generate input schema from method parameters
        final inputSchema = _generateInputSchema(method);
        if (inputSchema != null) {
          buffer.writeln('      inputSchema: $inputSchema,');
        }
      }

      buffer.writeln('    );');
    }

    buffer.writeln('  }');
    buffer.writeln('');

    // Collect available tools, resources, and prompts from the methods
    final availableTools = methods
        .where((m) => _getAnnotationType(m) == 'MCPTool')
        .map((m) => _getAnnotationName(m))
        .toList();
    final availableResources = methods
        .where((m) => _getAnnotationType(m) == 'MCPResource')
        .map((m) => _getAnnotationName(m))
        .toList();
    final availablePrompts = methods
        .where((m) => _getAnnotationType(m) == 'MCPPrompt')
        .map((m) => _getAnnotationName(m))
        .toList();

    buffer.writeln(
      '  /// Generates standardized usage documentation for MCP servers.',
    );
    buffer.writeln('  ///');
    buffer.writeln(
      '  /// This helper method provides consistent help text formatting',
    );
    buffer.writeln(
      '  /// for this specific MCP server with its available capabilities.',
    );
    buffer.writeln('  void showUsage({String? serverName}) {');
    buffer.writeln(
      '''    print('Usage: dart \${serverName ?? "server"}.dart [options]');
    print('');
    print('Options:');
    print('  --stdio        Start server in stdio mode (default)');
    print('  --http         Start HTTP server on port 8080');
    print('  --port <port>  Specify HTTP port (default: 8080)');
    print('  --help, -h     Show this help message');
    print('');''',
    );

    if (availableTools.isNotEmpty) {
      buffer.writeln(
        '    print(\'Available tools: ${availableTools.join(", ")}\');',
      );
    }
    if (availableResources.isNotEmpty) {
      buffer.writeln(
        '    print(\'Available resources: ${availableResources.join(", ")}\');',
      );
    }
    if (availablePrompts.isNotEmpty) {
      buffer.writeln(
        '    print(\'Available prompts: ${availablePrompts.join(", ")}\');',
      );
    }

    if (availableTools.isNotEmpty ||
        availableResources.isNotEmpty ||
        availablePrompts.isNotEmpty) {
      buffer.writeln('    print(\'\');');
    }

    buffer.writeln('''    print('Examples:');
    print('  dart \${serverName ?? "server"}.dart');
    print('  dart \${serverName ?? "server"}.dart --http');
    print('  dart \${serverName ?? "server"}.dart --http --port 3000');''');
    buffer.writeln('  }');
    buffer.writeln('');
    buffer.writeln('}');

    return buffer.toString();
  }

  /// Generate parameter extraction for required parameters using generic type inference
  String _generateRequiredParameterExtraction(
    String paramName,
    String paramType,
  ) {
    // Use generic type inference - let the context.param<T> method handle the conversion
    return 'final $paramName = context.param<$paramType>(\'$paramName\');';
  }

  /// Generate parameter extraction for optional parameters using generic type inference
  String _generateOptionalParameterExtraction(
    String paramName,
    String paramType,
    String defaultValue,
  ) {
    // Use generic type inference - let the context.optionalParam<T> method handle the conversion
    return 'final $paramName = context.optionalParam<$paramType>(\'$paramName\') ?? $defaultValue;';
  }

  /// Get string representation of Dart type for generic type parameters
  String _getTypeString(DartType type) {
    if (type.isDartAsyncFuture) {
      final futureType = type as InterfaceType;
      if (futureType.typeArguments.isNotEmpty) {
        return _getTypeString(futureType.typeArguments.first);
      }
    }

    // Handle common types
    if (type.isDartCoreString) return 'String';
    if (type.isDartCoreInt) return 'int';
    if (type.isDartCoreDouble) return 'double';
    if (type.isDartCoreBool) return 'bool';
    if (type.isDartCoreList) return 'List<dynamic>';
    if (type.isDartCoreMap) return 'Map<String, dynamic>';

    return type.getDisplayString();
  }

  /// Check if a method has any MCP annotation
  bool _hasAnyMCPAnnotation(MethodElement method) {
    // Use the type checkers to properly detect MCP annotations
    return _mcpToolChecker.hasAnnotationOfExact(method) ||
        _mcpResourceChecker.hasAnnotationOfExact(method) ||
        _mcpPromptChecker.hasAnnotationOfExact(method);
  }

  /// Get the annotation type for a method
  String _getAnnotationType(MethodElement method) {
    if (_mcpToolChecker.hasAnnotationOfExact(method)) {
      return 'MCPTool';
    } else if (_mcpResourceChecker.hasAnnotationOfExact(method)) {
      return 'MCPResource';
    } else if (_mcpPromptChecker.hasAnnotationOfExact(method)) {
      return 'MCPPrompt';
    }
    return 'MCPTool'; // Default fallback
  }

  /// Get the registration method name for an annotation type
  String _getRegistrationMethod(String annotationType) {
    switch (annotationType) {
      case 'MCPTool':
        return 'registerTool';
      case 'MCPResource':
        return 'registerResource';
      case 'MCPPrompt':
        return 'registerPrompt';
      default:
        return 'registerTool';
    }
  }

  /// Extract the name from the annotation
  String _getAnnotationName(MethodElement method) {
    // Try to get the name from the annotation, fallback to method name
    if (_mcpToolChecker.hasAnnotationOfExact(method)) {
      final annotation = _mcpToolChecker.firstAnnotationOfExact(method);
      if (annotation != null) {
        final nameValue = annotation.getField('name');
        if (nameValue != null && nameValue.toStringValue() != null) {
          return nameValue.toStringValue()!;
        }
      }
    } else if (_mcpResourceChecker.hasAnnotationOfExact(method)) {
      final annotation = _mcpResourceChecker.firstAnnotationOfExact(method);
      if (annotation != null) {
        final nameValue = annotation.getField('name');
        if (nameValue != null && nameValue.toStringValue() != null) {
          return nameValue.toStringValue()!;
        }
      }
    } else if (_mcpPromptChecker.hasAnnotationOfExact(method)) {
      final annotation = _mcpPromptChecker.firstAnnotationOfExact(method);
      if (annotation != null) {
        final nameValue = annotation.getField('name');
        if (nameValue != null && nameValue.toStringValue() != null) {
          return nameValue.toStringValue()!;
        }
      }
    }

    return method.name!;
  }

  /// Extract the description from the annotation
  String _getAnnotationDescription(MethodElement method) {
    if (_mcpToolChecker.hasAnnotationOfExact(method)) {
      final annotation = _mcpToolChecker.firstAnnotationOfExact(method);
      if (annotation != null) {
        final descValue = annotation.getField('description');
        if (descValue != null && descValue.toStringValue() != null) {
          return descValue.toStringValue()!;
        }
      }
    } else if (_mcpResourceChecker.hasAnnotationOfExact(method)) {
      final annotation = _mcpResourceChecker.firstAnnotationOfExact(method);
      if (annotation != null) {
        final descValue = annotation.getField('description');
        if (descValue != null && descValue.toStringValue() != null) {
          return descValue.toStringValue()!;
        }
      }
    } else if (_mcpPromptChecker.hasAnnotationOfExact(method)) {
      final annotation = _mcpPromptChecker.firstAnnotationOfExact(method);
      if (annotation != null) {
        final descValue = annotation.getField('description');
        if (descValue != null && descValue.toStringValue() != null) {
          return descValue.toStringValue()!;
        }
      }
    }

    return '';
  }

  /// Generate JSON schema for method parameters
  String? _generateInputSchema(MethodElement method) {
    // First check if the annotation already has an inputSchema
    if (_mcpToolChecker.hasAnnotationOfExact(method)) {
      final annotation = _mcpToolChecker.firstAnnotationOfExact(method);
      if (annotation != null) {
        final inputSchemaValue = annotation.getField('inputSchema');
        if (inputSchemaValue != null && !inputSchemaValue.isNull) {
          // If annotation has inputSchema, we should use it, but for now we'll generate from parameters
          // TODO: Parse the existing inputSchema from the annotation
        }
      }
    }

    final parameters = method.formalParameters;
    if (parameters.isEmpty) {
      return null;
    }

    final properties = <String, Map<String, dynamic>>{};
    final required = <String>[];

    for (final param in parameters) {
      final paramName = param.name;
      if (paramName == null) continue;

      final paramType = _getTypeString(param.type);
      final jsonType = _dartTypeToJsonType(paramType);

      properties[paramName] = {
        'type': jsonType,
        'description': '${_capitalizeFirst(paramName)} parameter',
      };

      if (!param.isOptional) {
        required.add(paramName);
      }
    }

    final schema = {
      'type': 'object',
      'properties': properties,
      if (required.isNotEmpty) 'required': required,
    };

    return _mapToString(schema);
  }

  /// Convert Dart type to JSON Schema type
  String _dartTypeToJsonType(String dartType) {
    switch (dartType.toLowerCase()) {
      case 'string':
        return 'string';
      case 'int':
      case 'integer':
        return 'integer';
      case 'double':
      case 'num':
      case 'number':
        return 'number';
      case 'bool':
      case 'boolean':
        return 'boolean';
      case 'list<dynamic>':
        return 'array';
      case 'map<string, dynamic>':
        return 'object';
      default:
        return 'string'; // Default fallback
    }
  }

  /// Convert a Map to a string representation for code generation
  String _mapToString(Map<String, dynamic> map) {
    final buffer = StringBuffer('{');
    final entries = map.entries.toList();

    for (int i = 0; i < entries.length; i++) {
      final entry = entries[i];
      final isLast = i == entries.length - 1;

      buffer.write('\n        \'${entry.key}\': ');
      buffer.write(_valueToString(entry.value, 2));
      if (!isLast) buffer.write(',');
    }

    buffer.write('\n      }');
    return buffer.toString();
  }

  /// Convert a value to string representation for code generation
  String _valueToString(dynamic value, int indentLevel) {
    final indent = '  ' * indentLevel;

    if (value is String) {
      return '\'$value\'';
    } else if (value is Map<String, dynamic>) {
      final buffer = StringBuffer('{');
      final entries = value.entries.toList();

      for (int i = 0; i < entries.length; i++) {
        final entry = entries[i];
        final isLast = i == entries.length - 1;

        buffer.write('\n$indent  \'${entry.key}\': ');
        buffer.write(_valueToString(entry.value, indentLevel + 1));
        if (!isLast) buffer.write(',');
      }

      buffer.write('\n$indent}');
      return buffer.toString();
    } else if (value is List) {
      final buffer = StringBuffer('[');
      for (int i = 0; i < value.length; i++) {
        final isLast = i == value.length - 1;
        buffer.write(_valueToString(value[i], indentLevel));
        if (!isLast) buffer.write(', ');
      }
      buffer.write(']');
      return buffer.toString();
    } else {
      return value.toString();
    }
  }

  /// Capitalize first letter of a string
  String _capitalizeFirst(String input) {
    if (input.isEmpty) return input;
    return input[0].toUpperCase() + input.substring(1);
  }
}
